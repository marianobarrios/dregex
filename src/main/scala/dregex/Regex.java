package dregex;

import java.util.List;
import java.util.regex.Pattern;

import dregex.impl.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;
import java.util.stream.Collectors;

/**
 * A regular expression, ready to be tested against strings, or to take part in an operation against another.
 * Internally, instances of this type have a DFA (Deterministic Finite Automaton).
 */
public abstract class Regex {

    private static final Logger logger = LoggerFactory.getLogger(Regex.class);

    private final Dfa dfa;

    /**
     * Return this regex's [[Universe]]. Only regexes of the same universe can be operated together.
     */
    private final Universe universe;

    public Universe universe() {
        return universe;
    }

    public Dfa getDfa() {
        return dfa;
    }

    protected Regex(Dfa dfa, Universe universe) {
        this.dfa = dfa;
        this.universe = universe;
    }

    private void checkUniverse(Regex other) {
        if (other.universe != universe) {
            throw new RuntimeException("cannot make operations between regex from different universes");
        }
    }

    /**
     * Return whether a string is matched by the regular expression (i.e. whether the string is included in the language
     * generated by the expression).
     * As the match is done using a DFA, its complexity is O(n), where n is the length of the string. It is constant
     * with respect to the length of the expression.
     */
    public boolean matches(CharSequence string) {
        return matchAndReport(string).matches;
    }

    /**
     * Similar to method [[matches]], except that also return how many characters were successfully matched in case of
     * failure.
     */
    public DfaAlgorithms.MatchResult matchAndReport(CharSequence string) {
        return DfaAlgorithms.matchString(dfa, universe.normalization().normalize(string));
    }

    /**
     * Intersect this regular expression with another. The resulting expression will match the strings that are
     * matched by the operands, and only those. Intersections take O(n⋅m) time, where n and m are the number of states of
     * the DFA of the operands.
     */
    public Regex intersect(Regex other) {
        checkUniverse(other);
        var start = System.nanoTime();
        var ret = new SynteticRegex(DfaAlgorithms.rewriteWithSimpleStates(DfaAlgorithms.doIntersect(this.dfa, other.dfa)), universe);
        var time = Duration.ofNanos(System.nanoTime() - start);
        logger.trace("{} and {} intersected in {}", this, other, time);
        return ret;
    }

    /**
     * Subtract other regular expression from this one. The resulting expression will match the strings that are
     * matched this expression and are not matched by the other, and only those. Differences take O(n⋅m) time, where n
     * and m are the number of states of the DFA of the operands.
     */
    public Regex diff(Regex other) {
        var start = System.nanoTime();
        checkUniverse(other);
        var ret = new SynteticRegex(DfaAlgorithms.rewriteWithSimpleStates(DfaAlgorithms.diff(this.dfa, other.dfa)), universe);
        var time = Duration.ofNanos(System.nanoTime() - start);
        logger.trace("{} and {} diffed in {}", this, other, time);
        return ret;
    }

    /**
     * Unite this regular expression with another. The resulting expression will match the strings that are matched by
     * either of the operands, and only those. Unions take O(n⋅m) time, where n and m are the number of states of the DFA
     * of the operands.
     */
    public Regex union(Regex other) {
        var start = System.nanoTime();
        checkUniverse(other);
        var ret = new SynteticRegex(DfaAlgorithms.rewriteWithSimpleStates(DfaAlgorithms.union(this.dfa, other.dfa)), universe);
        var time = Duration.ofNanos(System.nanoTime() - start);
        logger.trace("{} and {} unioned in {}", this, other, time);
        return ret;
    }

    /**
     * Return whether this expression matches at least one string in common with another. Intersections take O(n⋅m) time,
     * where n and m are the number of states of the DFA of the operands.
     */
    public boolean doIntersect(Regex other) {
        checkUniverse(other);
        return DfaAlgorithms.isIntersectionNotEmpty(this.dfa, other.dfa);
    }

    /**
     * Return whether this expressions matches every expression that is matched by another. An [[diff]] between the
     * two operands is done internally.
     */
    public boolean isSubsetOf(Regex other) {
        checkUniverse(other);
        return DfaAlgorithms.isSubsetOf(this.dfa, other.dfa);
    }

    /**
     * Return whether this expressions matches every expression that is matched by another, but the expressions are not
     * equal. Two [[diff]] between the two operands are done internally.
     */
    public boolean isProperSubsetOf(Regex other) {
        checkUniverse(other);
        return DfaAlgorithms.isProperSubset(this.dfa, other.dfa);
    }

    /**
     * Return whether this regular expression is equivalent to other. Two regular expressions are equivalent if they
     * match exactly the same set of strings. This operation takes O(n⋅m) time, where n and m are the number of states of
     * the DFA of the operands.
     */
    public boolean equiv(Regex other) {
        checkUniverse(other);
        return DfaAlgorithms.equivalent(this.dfa, other.dfa);
    }

    /**
     * Return whether this regular expression matches anything. Note that the empty string is a valid match.
     */
    public boolean matchesAtLeastOne() {
        return DfaAlgorithms.matchesAtLeastOne(dfa);
    }

    /*
     * @define flagsDesc match flags, a bit mask that may include `java.util.regex.Pattern.LITERAL`, and
     *                   `java.util.regex.Pattern.COMMENTS`.
     *
     * @define parseDesc In general, this method is not necessary; a call to one of the `compile` methods is simpler
     *                   and more direct. However, there are cases in which the intermediate [[ParsedRegex]]s are needed.
     *                   Most notably, when caching [[CompiledRegex]] instances (which are in general more expensive to
     *                   create).
     */

    private static RegexParser.Flags flagsFromBits(int bits) {
        return new RegexParser.Flags(
                dotMatcherFromFlags(bits),
                (bits & Pattern.LITERAL) != 0,
                (bits & Pattern.COMMENTS) != 0,
                (bits & Pattern.UNICODE_CHARACTER_CLASS) != 0,
                (bits & Pattern.CASE_INSENSITIVE) != 0,
                (bits & Pattern.UNICODE_CASE) != 0,
                (bits & Pattern.CANON_EQ) != 0,
                false);
    }

    /**
     * Parse a regular expression from a string.
     * <p>
     * $parseDesc
     */
    public ParsedRegex parse(String regex) {
        return parse(regex, 0);
    }

    /**
     * Parse a regular expression from a string, with the given flags.
     * <p>
     * $parseDesc
     *
     * @param flags $flagsDesc
     */
    public static ParsedRegex parse(String regex, int flags) {
        return RegexParser$.MODULE$.parse(regex, flagsFromBits(flags));
    }

    /**
     * Parse a set of regular expressions from a string, with the given flags.
     * <p>
     * $parseDesc
     *
     * @param flags $flagsDesc
     */
    public static List<ParsedRegex> parse(List<String> regexes, int flags) {
        return regexes.stream().map(r -> parse(r, flags)).collect(Collectors.toList());
    }

    /**
     * Compile a regex parsed using one of the `parse` methods.
     * <p>
     * $parseDesc
     */
    public static CompiledRegex compileParsed(ParsedRegex parsedRegex, Universe universe) {
        var start = System.nanoTime();
        var res = new CompiledRegex(parsedRegex.literal(), parsedRegex.tree(), universe);
        var time = Duration.ofNanos(System.nanoTime() - start);
        logger.trace("{} compiled in {}", parsedRegex.literal(), time);
        return res;
    }

    /**
     * Compile a regex from a string, using it's own [[Universe]], with the given flags.
     *
     * @param flags $flagsDesc
     */
    public static CompiledRegex compile(String regex, int flags) {
        var parsedRegex = parse(regex, flags);
        var start = System.nanoTime();
        var compiled = new CompiledRegex(regex, parsedRegex.tree(), new Universe(List.of(parsedRegex.tree()), parsedRegex.norm()));
        var time = Duration.ofNanos(System.nanoTime() - start);
        logger.trace("{} compiled in {}", compiled, time);
        return compiled;
    }

    private static DotMatch dotMatcherFromFlags(int flags) {
        if ((flags & Pattern.DOTALL) != 0) {
            return DotMatch.All;
        } else {
            if ((flags & Pattern.UNIX_LINES) != 0) {
                return DotMatch.UnixLines;
            } else {
                return DotMatch.JavaLines;
            }
        }
    }

    /**
     * Compiles a set of regular expressions in the same [[Universe]].
     */
    public static CompiledRegex compile(String regex) {
        return compile(regex, 0);
    }

    /**
     * Compiles a set of regular expressions in the same [[Universe]], with the given flags. Scala version.
     *
     * @param flags $flagsDesc
     */
    public static List<CompiledRegex> compile(List<String> regexes, int flags) {
        var parsedRegexes = parse(regexes, flags);
        var universe = new Universe(parsedRegexes.stream().map(r -> r.tree()).collect(Collectors.toList()), parsedRegexes.get(0).norm());
        return parsedRegexes.stream().map(r -> compileParsed(r, universe)).collect(Collectors.toList());
    }

    public static List<CompiledRegex> compile(List<String> regexes) {
        return compile(regexes, 0);
    }

    /**
     * Create a regular expression that does not match anything. Note that that is different from matching the empty
     * string. Despite the theoretical equivalence of automata and regular expressions, in practice there is no regular
     * expression that does not match anything.
     */
    public static Regex nullRegex(Universe u) {
        return new SynteticRegex(Dfa.nothingDfa, u);
    }

}
